# R code used in Ecological Applications article, “Pollen carryover, pollinator movement, and spatial context impact the delivery of pollination services in apple orchards”

# By Keng-Lou James Hung, Sophia L. Fan, Caroline G. Strang, Mia G. Park, and James D. Thomson

##### INFORMATION ABOUT THE SIMULATION CODE #####

# The "d.svdeposition" data matrix corresponds to data in Table D1 of the deposited project data.
# The "d.visitrate" data matrix corresponds to data in Table D2 of the deposited project data.
# The "d.sequences" data matrix corresponds to data in Table D3 of the deposited project data.

# Deposited project data can be accessed at the following URL: https://doi.org/10.17605/OSF.IO/VF3X5

# Two examples are given, one for the "non-SI" scheme and one for the "blocks" scheme.
# The "blocks" scheme can be modified to simulate all other orchard layout schemes
# that involve self-incompatibility and pollen carryover by modifying how frequently
# a transition event results in starting a new sequence of outcross pollen deposition; 
# the relevant code that differs among orchard layout schemes are in PART 3 of the 
# simulation code, and are provided at the bottom of this appendix, with the exception
# of the "trees" scheme in which every switching event starts a new sequence (and thus
# the entirety of the simulation is much simplified).

# Examples show simulations for mining bees only; repeat the simulation for honey bees
# and bumble bees and collate final data for analysis.

# Questions about the code should be directed to KLJ Hung: <kenglou.hung@gmail.com>



##### SIMULATION FOR THE "NON-SI" ORCHARD SCHEME #####

# Load the fitdistrplus() package
# See Delignette-Muller, M. L., and C. Dutang. 2015. fitdistrplus: 
# An R Package for Fitting Distributions. Journal of Statistical Software 64(4):1–34.
library(fitdistrplus)

##### PART 1. Define simulation parameters #####
# Define the numbers of individuals to simulate
x.indivs = 5
# Define the number of flowers each individual visits in its foraging bout
x.reps = 25
# Define the number of pollen grains needed per flower to be considered a full load
x.full = 200


##### PART 2. Set up simulation data and variables #####
# Subset pollen deposition dataset to mining bees
xsim.temp = d.svdeposition[which(d.svdeposition$Bee_identity == "Mining bee") , ]
xsim.temp = as.numeric(as.character(xsim.temp$Num_apple_pollen_deposited))

# Define the data frames that will store the variables used in / generated by the simulations
xsim.pollen = data.frame(matrix(nrow = x.indivs, ncol = x.reps))
dsim.Mining = data.frame(matrix(nrow = x.indivs, ncol = 6))
colnames(dsim.Mining) = c("Bee_identity", "Visitation_rate",
                          "Num_full_load_equivalents", "Time_spent", "Eff_temporal", "Eff_resource")


##### PART 3. Assign how much pollen is received by each flower #####

# Randomly generate pollen deposition data from negative binomial distribution 
# paramaterized from empirical data, and store into matrix
xfit.temp = fitdist(xsim.temp, 'nbinom')
xsim.pollen[] = rnbinom(x.indivs*x.reps, size = xfit.temp$estimate[1], mu = xfit.temp$estimate[2])

# Replace zeroes with ones to bound pollen deposition at 1 grain
xsim.pollen[xsim.pollen == 0] <- 1 

# Convert each pollen value into full pollen load equivalents
xsim.pollen = xsim.pollen/x.full

# Cap pollen load to 1 if exceeding the full pollen load
xsim.pollen[xsim.pollen > 1] = 1


##### PART 4. Data collation #####
# First subset visitation rate dataset to just mining bees, 
# and isolate Num_flowers_visited_per_min
xsim.temp = d.visitrate[which(d.visitrate$Bee_identity == "Mining bee") , ]
xsim.temp = as.vector(xsim.temp$Num_flowers_visited_per_min)

# Randomly generate visitation rate data from gamma distribution 
# paramaterized from empirical data, and store into matrix
xfit.temp = fitdist(xsim.temp, 'gamma')
dsim.Mining$Visitation_rate = rgamma(x.indivs,xfit.temp$estimate[1], xfit.temp$estimate[2])

# Assign pollen deposition results into the collation dataset
dsim.Mining$Bee_identity = "Mining bee"
dsim.Mining$Num_full_load_equivalents = rowSums(xsim.pollen)
dsim.Mining$Time_spent = x.reps / dsim.Mining$Visitation_rate
dsim.Mining$Eff_temporal = dsim.Mining$Num_full_load_equivalents / dsim.Mining$Time_spent
dsim.Mining$Eff_resource = dsim.Mining$Num_full_load_equivalents / x.reps




##### SIMULATION FOR THE "BLOCKS" ORCHARD SCHEME #####

# Load the fitdistrplus() package
# See Delignette-Muller, M. L., and C. Dutang. 2015. fitdistrplus: 
# An R Package for Fitting Distributions. Journal of Statistical Software 64(4):1–34.
library(fitdistrplus)

##### PART 1. Define simulation parameters #####
# Define the numbers of individuals to simulate
x.indivs = 5
# Define the number of trees each individual visits in its foraging bout
x.reps = 25
# Define the number of pollen grains needed per stigma to be considered a full load
x.full = 200
# Define the number of rows in a block of same-cultivar trees
x.blk = 6
# Define pollen carryover parameters
x.lambda = 0.335     # higher number = steeper decline in pollen carryover
x.b = -0.289         # more negative = more leptokurtic


##### PART 2. Set up simulation data and variables #####
# Subset to the desired pollinator group
xsim.temp.visits = d.sequences[ which(d.sequences$Bee_identity == "Mining bee") , ]

# Remove bees whose transition vector ends in "Lost"
xsim.temp.visits = xsim.temp.visits[ -which(xsim.temp.visits$Transition_vector == "Lost"), ]

# Replace Within and Across with 0 and 1, then subset to just the needed data
xsim.temp.visits$Transition_vector = as.character(xsim.temp.visits$Transition_vector)
xsim.temp.visits$Transition_vector[xsim.temp.visits$Transition_vector == "Across rows"] = 1
xsim.temp.visits$Transition_vector[xsim.temp.visits$Transition_vector == "Within row"] = 0
xsim.temp.visits$Transition_vector = as.numeric(xsim.temp.visits$Transition_vector) 
xsim.temp.visits = xsim.temp.visits[c("Num_flowers_visited", "Transition_vector")]

# Define the data frames that will store the variables used in / generated by the simulations
xsim.visits = data.frame(matrix(nrow = x.reps, ncol = x.indivs))
xsim.vectors = xsim.visits
xsim.blockprob = xsim.vectors
xsim.consecutive = xsim.visits
xsim.pollen = xsim.visits
xsim.pollinate = xsim.visits
xsim.drawn = data.frame(matrix(nrow = 3, ncol = x.indivs))
dsim.Mining = data.frame(matrix(nrow = x.indivs, ncol = 8))
colnames(dsim.Mining) = c("Bee_identity", "Visitation_rate", "Num_visits", "Num_switches",
                          "Num_full_load_equivalents", "Time_spent", "Eff_temporal", "Eff_resource")
dsim.carryovers.Mining = data.frame(matrix(nrow = 1, ncol = 3))


##### PART 3. Populating visitation and transition vector matrices #####
# Randomly generate number of flowers visited per tree from negative binomial
# distribution paramaterized from empirical data, and store into matrix
xfit.temp = fitdist(xsim.temp.visits$Num_flowers_visited, 'nbinom')
xsim.visits[] = rnbinom(x.indivs*x.reps, size = xfit.temp$estimate[1], mu = xfit.temp$estimate[2])

# Replace zeroes with ones to bound number of flowers visited per tree to 1 flower
xsim.visits[xsim.visits == 0] <- 1 

# Generate vectors of transition probabilities based on % of switches in empirical data
xsim.vectors[] = rbinom(x.indivs*x.reps, size = 1, prob = 
                          (sum(xsim.temp.visits$Transition_vector)/length(xsim.temp.visits$Transition_vector)))

# Multiply matrix of transition vectors by random draw of likelihood of leaving the block
# In this case, a block is 6 rows wide.
xsim.blockprob[,] = rbinom(x.indivs*x.reps, size = 1, prob=(1/x.blk))
xsim.vectors = xsim.vectors*xsim.blockprob


##### PART 4. Group consecutive visits to the same block into a single series #####
xsim.consecutive = xsim.visits
i = 1     # start the loop on the second entry of the matrix 
while (i < x.reps)
{ i = i + 1;
xsim.consecutive[i,] = ifelse(xsim.vectors[i-1,]==0, 
                              xsim.visits[i,] + xsim.consecutive[i-1,], xsim.visits[i,])
xsim.consecutive[i-1,] = ifelse(xsim.vectors[i-1,]==0, 
                                0, xsim.consecutive[i-1,])
}

##### PART 5. Assign how much pollen is received by each flower, with pollen carryover in each series #####
# Isolate Mining bees' pollen deposition data
xsim.temp.pollen = d.svdeposition[ which(d.svdeposition$Bee_identity == "Mining bee") , ]
xsim.temp.pollen = as.numeric(as.character(xsim.temp.pollen$Num_apple_pollen_deposited))

# Randomly generate pollen deposition data from negative binomial distribution 
# paramaterized from empirical data, and store into matrix
xfit.temp = fitdist(xsim.temp.pollen, 'nbinom')
xsim.pollen[] = rnbinom(x.indivs*x.reps, size = xfit.temp$estimate[1], mu = xfit.temp$estimate[2])

# Replace zeroes with ones to bound pollen deposition at 1 grain
xsim.pollen[xsim.pollen == 0] <- 1 

# Use as.logical() function to zero out all entries where xsim.consecutive is zero--
# i.e., those whose visits get carried to the next entry due to visiting the same row
xsim.pollen = xsim.pollen * as.logical(xsim.consecutive > 0) 

# Set up matrix of individual runs of each bee, with corresponding pollen carryover
dsim.carryovers.Mining = as.data.frame(matrix(nrow =
                                                sum(as.logical(xsim.consecutive > 0)), ncol = 6 + max(xsim.consecutive)))
colnames(dsim.carryovers.Mining) = c("Bee_identity", "Bee.num", "Run.num", "Run.length",
                                     "Pollen.sum", "Loads.sum", paste(seq(1, max(xsim.consecutive), 1)))
dsim.carryovers.Mining$Bee_identity = "Mining bee"

# Convert each value into full pollen load equivalents and store in xsim.pollinate matrix
xsim.pollinate = xsim.pollen/x.full

# Derive P0 from b and lambda sensu Morris et al. 1994 equation 3
P0 = 1 / (x.lambda * 1^x.b * (1 - x.lambda)) 
# Define a vector for storing product operation of Morris 1994 equation 3
x.prod = as.vector(0)

# Construct the product operator from Equation 3 of Morris et al. 1994
for (k in c(0:max(xsim.consecutive))) 
{ k = k+1
x.prod[k] = (1 - x.lambda*k^x.b) }

# Construct loop to generate pollen carryover series for each matrix element
j = 0
k = 0      # k tracks which row to enter data for the dsim.carryovers.Mining matrix

while (j < x.indivs)     # Repeat over number of individuals
{ j = j + 1;
i = 0    
while (i < x.reps)     # Repeat over number of tree sequences
{ i = i + 1;

# Skip the carryover operation altogether if matrix element is zero; i.e., the visit on 
# the tree in question is combined with other trees in the same block
if (xsim.pollen[i,j] == 0) {
  xsim.pollinate[i,j] = 0
} else {
  
  # Generate a vector that has the pre-defined pollen carryover shape, same length as the
  # number of consecutive visits documented in the xsim.consecutive matrix.
  # Reset x.P, and then loop to generate pollen carryover curve
  x.P = as.vector(0)
  for (n in c(0:(xsim.consecutive[i,j])))
  { n = n+1
  x.P[n] = P0 * x.lambda * n^x.b * prod(x.prod[c(1:n-1)])
  }
  
  # Multiply pollen carryover values by pollen load equivalents
  x.P[1] = 1  # The first entry should not have any wiggle 
  x.P = x.P * xsim.pollinate[i,j]
  
  # Save carryover curve to the dsim.carryovers.Mining matrix
  k = k + 1
  dsim.carryovers.Mining[k,2] = colnames(xsim.pollinate[j])
  dsim.carryovers.Mining[k,3] = rownames(xsim.pollinate[i,])
  dsim.carryovers.Mining[k,4] = length(x.P)
  dsim.carryovers.Mining[k,5] = sum(x.P*x.full)
  dsim.carryovers.Mining[k,c(7:(length(x.P)+6))] = x.P*x.full
  
  # Cap pollen load to 1 if exceeding the full pollen load
  x.P[x.P > 1] = 1
  # Sum the vector and put into xsim.pollinate and dsim.carryovers.Mining matrices
  xsim.pollinate[i,j] = sum(x.P)
  dsim.carryovers.Mining[k,6] = sum(x.P)
  
} # This closes the else statement
} # This closes the while loop for j
} # This closes the while loop for i

##### PART 6. Data collation #####
# First subset visitation rate dataset to just mining bees, and isolate
# Num_flowers_visited_per_min
xsim.temp.collate = d.visitrate[ which(d.visitrate$Bee_identity == "Mining bee") , ]
xsim.temp.collate = as.vector(xsim.temp.collate$Num_flowers_visited_per_min)

# Randomly generate visitation rate data from gamma distribution 
# paramaterized from empirical data, and store into matrix
xfit.temp = fitdist(xsim.temp, 'gamma')
dsim.Mining$Visitation_rate = rgamma(x.indivs,xfit.temp$estimate[1], xfit.temp$estimate[2])

# Assign simulation loop results into the collation dataset
dsim.Mining$Bee_identity = "Mining bee"
dsim.Mining$Num_visits = colSums(xsim.visits)
dsim.Mining$Num_switches = colSums(xsim.vectors)
dsim.Mining$Num_full_load_equivalents = colSums(xsim.pollinate)
dsim.Mining$Time_spent = dsim.Mining$Num_visits / dsim.Mining$Visitation_rate
dsim.Mining$Eff_temporal = dsim.Mining$Num_full_load_equivalents / dsim.Mining$Time_spent
dsim.Mining$Eff_resource = dsim.Mining$Num_full_load_equivalents / dsim.Mining$Num_visits
dsim.Mining$Orchard_context = "Blocks of 6 rows"
dsim.Mining$lambda = x.lambda
dsim.Mining$b = x.b




##### CODE FOR PART 3 WITH THE "ROWS" SCHEME #####
# Randomly generate number of flowers visited per tree from negative binomial
# distribution paramaterized from empirical data, and store into matrix
xfit.temp = fitdist(xsim.temp.visits$Num_flowers_visited, 'nbinom')
xsim.visits[] = rnbinom(x.indivs*x.reps, size = xfit.temp$estimate[1], mu = xfit.temp$estimate[2])

# Replace zeroes with ones to bound number of flowers visited per tree to 1 flower
xsim.visits[xsim.visits == 0] <- 1 

# Generate vectors of transition probabilities based on % of switches in empirical data
xsim.vectors[] = rbinom(x.indivs*x.reps, size = 1, prob = 
                          (sum(xsim.temp.visits$Transition_vector)/length(xsim.temp.visits$Transition_vector)))




##### CODE FOR PART 3 WITH THE "POLLINIZERS" SCHEME #####
# First, define frequency of pollinizers: one pollinizer out of how many trees?
x.plz = 5

# Then, determine transitions
# Randomly generate number of flowers visited per tree from negative binomial
# distribution paramaterized from empirical data, and store into matrix
xfit.temp = fitdist(xsim.temp.visits$Num_flowers_visited, 'nbinom')
xsim.visits[] = rnbinom(x.indivs*x.reps, size = xfit.temp$estimate[1], mu = xfit.temp$estimate[2])

# Replace zeroes with ones to bound number of flowers visited per tree to 1 flower
xsim.visits[xsim.visits == 0] <- 1 

# Generate matrix of trees visited, with 1 being pollinizer and 0 being main cultivar
xsim.blockprob[,] = rbinom(x.indivs*x.reps, size = 1, prob=(1/x.plz))

# Congregate non-switching events together into the same run whereby 0 indicates no variety switch.
# This is achieved by checking if the tree visited in element i is the same cultivar as 
# that visited in element i+1 (if same, no switch between i and i+1).
# Have to use WHILE loop because FOR loop breaks down for this ifelse construction for some reason??
i = 0     # start the loop on the first entry of the matrix 
while (i < x.reps-1)
{i = i + 1;
xsim.vectors[i,] = ifelse(xsim.blockprob[i,] == xsim.blockprob[i+1,], 0, 1)
}
xsim.vectors = xsim.vectors[-x.reps,]
# Note that we don't have a transition vector associated with the last tree visited in 
# the sequence since we don't know where the bee transitioned to, and it doesn't matter.
