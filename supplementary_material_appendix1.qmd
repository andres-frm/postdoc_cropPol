---
title: "How much is enough? Optimizing beehive stocking densities to maximize the production of a pollinator-dependent crop"
subtitle: 'Appendix S1. Journal: Ecological Applications'
author: "Andrés F. Ramírez-Mejía"
format: 
  html:
    theme: 
      light: journal
      dark: [journal, theme-dark.scss]
    toc: true
    toc-depth: 10
    toc-expand: 10
    toc-title: "Content"
    toc-location: left
    embed-resources: true
number-sections: true
number-depth: 10
mainfont: Times New Roman
code-fold: false
code-overflow: scroll
code-line-numbers: true
code-copy: true
---

This document reproduces the data wrangling, modelling and simulations from *Ramírez-Mejía et al. How much is enough? Optimizing beehive stocking densities to maximize the production of a pollinator-dependent crop*. I provided  annotations along the entire script, with emphasizing on the modelling and simulations sections. Also, in order to facilitate reading the script, I organized it in the same order of the simulation phases: **(i)** the scenario, **(ii)** hives and bees, **(iii)** foraging pattern of honeybees, **(iv)** floral visits and pollen deposition, and **(v)** final crop yield.

# (i) The scenario

## Data pollination exclusion experiments

### Northwestern Region of Argentina
During two years, we did pollinator exclusion experiments in  nine blueberry farms with an average separation of 9.5 km between contiguous farms. Each experiment consisted of two flowering branch per plant (15 plants per farm, N = 135), where we recorded the number of flowers setting fruit. One branch was surrounded with a nylon bag to prevent pollinators visiting flowers while the other remained open to animal pollination. We used the Emerald cultivar in all experiments.

### Central Region of Argentina

Pablo...

## Data wrangling

The following code read into `R` and merge both data sets in a list object `dat_fs`. This is the data structure needed to fit the following Bayesian model.

```{r results='hide', message=FALSE, warning=FALSE}
pks <- c('tidyverse', 'rethinking', 'rstan', 'magrittr', 'cmdstanr',
         'ggdag', 'dagitty', 'readxl', 'brms', 'cowplot', 'parallel', 
         'compiler', 'KneeArrower')

sapply(pks, library, character.only = T)

options(mc.core = parallel::detectCores())

source('functions_mod_diagnostics.r') 
# this is an script to load functions for bayesian model diagnostics
```

```{r}
dat_fs <- readRDS('fruit_set.rds')

dat_fs <- dat_fs[, c("plant_id", "farm_id", "year_id",
                     "beehive", "treatment", "flowers", "fruits")]

dat_fs$treatment <- ifelse(dat_fs$treatment == 1, 'close', 'open')

dat_fs2 <- lapply(6:7, 
                  function(x) {
                    t <- read_xlsx('tesis_pablo.xlsx', 
                                   shee = x, 
                                   col_names = T, 
                                   na = 'NA')[, 1:5]
                    
                    t$locality <- 'entre_rios'
                    t$treatment <- 'open'
                    
                    colnames(t) <- c('farm_id', 'plant_id', 'branch_id',
                                     'flowers', 'fruits', 'locality_id', 
                                     'treatment')

                    t$branch_id <- t %$% paste(farm_id,
                                              plant_id,
                                              branch_id,
                                              sep = '')

                    t$plant_id <- t %$% paste(farm_id,
                                              plant_id,
                                              sep = '')
                    
                    t
                  })

names(dat_fs2) <- paste('y', c(2016, 2021), sep = '')
dat_fs2$y2016$year_id <- '2016'
dat_fs2$y2021$year_id <- '2021'

dat_fs$branch_id <- 1
dat_fs$locality_id <- 'tucuman'


dat_fs <- dat_fs[, c("farm_id", "plant_id", 
                     'branch_id', "flowers", 
                     "fruits", "locality_id", 
                     "treatment", "year_id")]

dat_fs$branch_id <- paste(dat_fs$farm_id, dat_fs$plant_id, 
                          dat_fs$branch_id, sep = '_')
dat_fs$plant_id <- paste(dat_fs$farm_id, 
                         dat_fs$plant_id, sep = '_')


dat_fs <- rbind(dat_fs, dat_fs2$y2016, dat_fs2$y2021)

dat_fs <- na.omit(dat_fs)

dat_fs <- 
  lapply(dat_fs, 
         function(x) {
           if (is.character(x)) as.numeric(as.factor(x))
           else x
         })

unlist(lapply(dat_fs, function(x) sum(is.na(x))))

dat_fs$N <- length(dat_fs$plant_id)
dat_fs$N_site <- length(unique(dat_fs$locality_id))
dat_fs$N_farm <- length(unique(dat_fs$farm_id))
dat_fs$N_plant <- length(unique(dat_fs$plant_id))
dat_fs$N_branch <- length(unique(dat_fs$branch_id))
dat_fs$N_treatment <- length(unique(dat_fs$treatment))
dat_fs$N_year <- length(unique(dat_fs$year_id))

```

## Model 1: probability of blueberry flowers setting fruit

### Matematical version

$$

\begin{align}

& fruits~produced_i \sim binomial(n~sampled~flowers_i, ~p_i)\\
& logit(p_i) = \alpha_{treatment_i} + \theta_{[plant_i, treatmen_i]} + \\ 
& \delta_{[farm_i, treatment_i]} + \lambda_{[region_i, treatment_i]} + \gamma_{[year_i, treatment_i]} \\
& \alpha_{treatment} \sim normal(0, 1) \\
& \theta_{[plant_i, treatmen_i]}  = (diag(\sigma_\theta), R_{cholesky~\theta}Z_\theta)^T \\
& \delta_{[farm_i, treatment_i]} = (diag(\sigma_\delta), R_{cholesky~\delta}Z_\delta)^T \\
& \lambda_{[region_i, treatment_i]} = (diag(\sigma_\lambda), R_{cholesky~\lambda}Z_\lambda)^T \\
& \gamma_{[year_i, treatment_i]} = (diag(\sigma_\gamma), R_{cholesky~\gamma}Z_\gamma)^T \\
& \sigma_\theta \sim exponential(1) \\
& \sigma_\delta \sim exponential(1) \\
& \sigma_\lambda \sim exponential(1) \\
& \sigma_\gamma \sim exponential(1) \\
& R_{cholesky~\theta} \sim LKJCorr(2) \\
& R_{cholesky~\delta} \sim LKJCorr(2) \\
& R_{cholesky~lambda} \sim LKJCorr(2) \\
& R_{cholesky~\gamma} \sim LKJCorr(2) \\
& Z_\theta \sim normal(0, 0.5) \\
& Z_\delta \sim normal(0, 0.5) \\
& Z_\lambda \sim normal(0, 0.5) \\
& Z_\gamma \sim normal(0, 0.5) \\

\end{align}

$$
We used $\alpha_{treatment} \sim normal(0, 1)$ as intercept, with a 
parametrization covering values from $-3.4$ to $3.4$ in the logit scales, which
basically implies all possible values in a probability scale. $LKJCorr(2)$ set 
values from $-1$ to $1$ for the probability distribution of correlations. $exponential(1)$ and $normal(0, 0.5)$ set standard priors for the dispersion and groupl-level effects parameters. We fitted the model using a non-centered parametrization.

### Model in Stan code

```{r eval=FALSE, echo=TRUE}
cat(file = 'fruit_set.stan', 
    "
    data{
      int N;
      int N_site;
      int N_farm;
      int N_plant;
      //int N_branch;
      int N_treatment;
      int N_year;
      array[N] int flowers;
      array[N] int fruits;
      array[N] int year_id;
      array[N] int locality_id;
      array[N] int farm_id;
      array[N] int plant_id;
      //array[N] int branch_id;
      array[N] int treatment;
    }
    
    parameters{
      vector[N_treatment] t;
      
      matrix[N_treatment, N_year] Z_year;
      cholesky_factor_corr[N_treatment] R_year;
      vector<lower = 0>[N_treatment] sigma_year;
      
      matrix[N_treatment, N_site] Z_locality;
      cholesky_factor_corr[N_treatment] R_locality;
      vector<lower = 0>[N_treatment] sigma_locality;
    
      matrix[N_treatment, N_farm] Z_farm;
      cholesky_factor_corr[N_treatment] R_farm;
      vector<lower = 0>[N_treatment] sigma_farm;
    
      matrix[N_treatment, N_plant] Z_plant;
      cholesky_factor_corr[N_treatment] R_plant;
      vector<lower = 0>[N_treatment] sigma_plant;
      
      //vector[N_branch] branch;
      
    }
    
    transformed parameters{
      matrix[N_year, N_treatment] year;
      matrix[N_site, N_treatment] locality;
      matrix[N_farm, N_treatment] farm;
      matrix[N_plant, N_treatment] plant;
    
      year = (diag_pre_multiply(sigma_year, R_year) * Z_year)';
      locality = (diag_pre_multiply(sigma_locality, R_locality) * Z_locality)';
      farm = (diag_pre_multiply(sigma_farm, R_farm) * Z_farm)';
      plant = (diag_pre_multiply(sigma_plant, R_plant) * Z_plant)';
    }
    
    model{
      vector[N] p;
      t ~ normal(0, 1);
    
      to_vector(Z_year) ~ normal(0, 0.5);
      R_year ~ lkj_corr_cholesky(2);
      sigma_year ~ exponential(1);
    
      to_vector(Z_locality) ~ normal(0, 0.5);
      R_locality ~ lkj_corr_cholesky(2);
      sigma_locality ~ exponential(1);
    
      to_vector(Z_farm) ~ normal(0, 0.5);
      R_farm ~ lkj_corr_cholesky(2);
      sigma_farm ~ exponential(1);
    
      to_vector(Z_plant) ~ normal(0, 0.5);
      R_plant ~ lkj_corr_cholesky(2);
      sigma_plant ~ exponential(1);
      //branch ~ normal(0, 1);
    
      for (i in 1:N) {
        p[i] = t[treatment[i]] + 
                locality[locality_id[i], treatment[i]] + 
                farm[farm_id[i], treatment[i]] +
                plant[plant_id[i], treatment[i]] +
                year[year_id[i], treatment[i]]; 
        
        p[i] = inv_logit(p[i]);
      }
      
      fruits ~ binomial(flowers, p);
    }
    
    generated quantities{
      vector[N] log_lik;
      vector[N] p1;
      array[N] int ppcheck;
      matrix[N_treatment, N_treatment] Rho_year;
      matrix[N_treatment, N_treatment] Rho_locality;
      matrix[N_treatment, N_treatment] Rho_farm;
      matrix[N_treatment, N_treatment] Rho_plant;
    
      Rho_year = multiply_lower_tri_self_transpose(R_year);
      Rho_locality = multiply_lower_tri_self_transpose(R_locality);
      Rho_farm = multiply_lower_tri_self_transpose(R_farm);
      Rho_plant = multiply_lower_tri_self_transpose(R_plant);
    
      for (i in 1:N) {
        p1[i] = t[treatment[i]] + 
                locality[locality_id[i], treatment[i]] + 
                farm[farm_id[i], treatment[i]] +
                plant[plant_id[i], treatment[i]] +
                year[year_id[i], treatment[i]]; 
        
        p1[i] = inv_logit(p1[i]);
      }
      
      for (i in 1:N) log_lik[i] = binomial_lpmf(fruits[i] | flowers[i], p1[i]);
    
      ppcheck = binomial_rng(flowers, p1);
    }
    ")

```

### Running MCMC algorith and model's outputs

```{r eval = F}
file <- paste(getwd(), '/fruit_set.stan', sep = '')

fit_fruit_set <- cmdstan_model(file, compile = T)

mod_fs_exp <- 
  fit_fruit_set$sample(
    data = dat_fs, 
    chains = 3, 
    parallel_chains = 3, 
    iter_warmup = 500, 
    iter_sampling = 4e3,
    thin = 3,
    seed = 123,
    refresh = 500
  )
```


#### Model's diagnostics
```{r warning=FALSE, message=FALSE}

mod_fs_exp <- readRDS('mod_blueberry_fs.rds')

output_mod_fruitset <- mod_fs_exp$summary() 

mod_diagnostics(mod_fs_exp, output_mod_fruitset)

par(mfrow = c(3, 3), mar = c(4, 4, 1, 1))
for (i in 2:10) {
  trace_plot(mod_fs_exp, output_mod_fruitset$variable[i], 3)
}
par(mfrow = c(1, 1))

post_fruitset <- mod_fs_exp$draws(format = 'df')

post_fruitset <- as.matrix(post_fruitset)

```
Chain convergence ok and enough *ess* for all parameters. We had some observations with high pareto-k values, but, as you can see below, the model predicts well the observed data.

#### Model's ppcheck

```{r}
post_fruitset <- 
  list(treatment = post_fruitset[, grep('^t', colnames(post_fruitset))], 
       locality = post_fruitset[, grep('^locality', colnames(post_fruitset))], 
       farm = post_fruitset[, grep('^farm', colnames(post_fruitset))], 
       plant = post_fruitset[, grep('^plant', colnames(post_fruitset))],
       year = post_fruitset[, grep('^year', colnames(post_fruitset))])

ppcheck_fruit_set <- mod_fs_exp$draws(variables = 'ppcheck', format = 'matrix')

plot(density(ppcheck_fruit_set[1, ]), ylim = c(0, 0.025), lwd = 0.1, 
     main = '', xlab = 'Number of fruit')
for (i in 1:100) lines(density(ppcheck_fruit_set[i, ]), lwd = 0.1)
lines(density(dat_fs$fruits), col = 'red', lwd = 2)
```

ppcheck ok!

Extracting the marginalized posterior distribution of flowers setting fruit in open pollination treatment.
```{r}
fruit_set <- 
  inv_logit(
    post_fruitset$treatment[, 2, drop = T] +
      apply(post_fruitset$locality, 1, mean) + 
      apply(post_fruitset$farm, 1, mean) +
      apply(post_fruitset$plant, 1, mean) +
      apply(post_fruitset$year, 1, mean) 
  )

plot(density(fruit_set), main = '', 
     xlab = 'Probability of blueberry\n flowers setting fruit', col = 'lightblue', lwd = 4)

```

## Data fruits production per plant

During the 2021 production season of the Northwestern Argentina, we use three farms to estimate the number of fruits produced by blueberry bushes. At each farm we chose five to six plots (Emerald cultivar, plot size $1.31~\pm~0.09~ha$ 0.09 ha) distributed from the farm border to interior to encompass potential variation in underlying pollination services, soil condition, irrigation system and plant age. The average nearest distance among plots was $384.4~\pm~197.5~m$. At each location we randomly selected five plants and counted the total number of fruits on two randomly chosen primary branches. The product of the average number of fruits per primary branch and number of primary branches was used as an estimate of total fruits produced by the plant.

## Data wrangling

```{r}
fruit_plant <- readRDS('fruit_plant.rds')

fruit_plant$plant_id <- as.factor(paste(fruit_plant$farm, fruit_plant$plant, sep = '_'))

fruit_plant$plot <- as.factor(paste(fruit_plant$farm, fruit_plant$plot, sep = '_'))

fruit_plant <- fruit_plant[, c("farm", "plot", 'plant_id', "total_fruts")]

fruit_plant <- lapply(fruit_plant, function(x) if(is.factor(x)) as.numeric(x) else(x))

fruit_plant$N <- length(fruit_plant$farm)
fruit_plant$N_farm <- length(unique(fruit_plant$farm))
fruit_plant$N_plot <- length(unique(fruit_plant$plot))
fruit_plant$N_plant <- length(unique(fruit_plant$plant))
fruit_plant$total_fruts <- round(fruit_plant$total_fruts)
```

## Model 2: number of fruits produced by a blueberry bush

### Matematical version

$$
\begin{align}

& Total~fruit~bush_i \sim negative~binomial(\lambda_i, \sigma) \\
& log(\lambda_i) = \alpha_{plant~i} + \theta_{plot~i} + \delta_{farm~i} \\
& \alpha_{plant~i} = \mu_\alpha + Z_\alpha \times \sigma_\alpha \\
& \theta_{plot~i} = \mu_\theta + Z_\theta \times \sigma_\theta \\
& \delta_{farm~i} = \mu_\delta + Z_\delta \times \sigma_\delta \\
& \mu_\alpha \sim normal(7, 2) \\
& \mu_\theta \sim normal(0, 1) \\
& \mu_\delta \sim normal(0, 1) \\
& Z_\alpha \sim normal(0, 1) \\
& Z_\theta \sim normal(0, 1) \\
& Z_\delta \sim normal(0, 1) \\
& \sigma_\alpha \sim exponential(1) \\
& \sigma_\theta \sim exponential(1) \\
& \sigma_\delta \sim exponential(1) \\

\end{align}
$$
We used the $plant_i$ as the model's intercept, so the exponentiation of $normal(7, 2)$ denotes the expected average number of number of fruits per blueberry bush ($\lambda_i$ parameter). We used a non-centered parametrization to fit the model.

### Model in Stan code

```{r eval=T}
cat(file = 'fruits_plant.stan', 
    "
    data{
      int N;
      int N_farm;
      int N_plot;
      int N_plant;
      array[N] int plant_id;
      array[N] int total_fruts;
      array[N] int farm;
      array[N] int plot;
    }
    
    parameters{
      vector[N_plant] z_plant;
      real mu_plant;
      real<lower = 0> sigma_plant;
    
      vector[N_farm] z_farm;
      real mu_farm;
      real<lower = 0> sigma_farm;
    
      vector[N_plot] z_plot;
      real mu_plot;
      real<lower = 0> sigma_plot;
    
      real<lower = 0> scale;
    }
    
    transformed parameters{
      vector[N_plant] theta;
      vector[N_farm] alpha;
      vector[N_plot] tau;
      theta = mu_plant + z_plant * sigma_plant;
      alpha = mu_farm + z_farm * sigma_farm;
      tau = mu_plot + z_plot * sigma_plot;
      
    }
    
    model{
      vector[N] mu;
    
      mu_plant ~ normal(7, 2);
      z_plant ~ normal(0, 1);
      sigma_plant ~ exponential(1);
    
      mu_farm ~ normal(0, 1);
      z_farm ~ normal(0, 1);
      sigma_farm ~ exponential(1);
      
      mu_plot ~ normal(0, 1);
      z_plot ~ normal(0, 1);
      sigma_plot ~ exponential(1);
    
      scale ~ exponential(1);
    
      for (i in 1:N) {
        mu[i] = theta[plant_id[i]] + alpha[farm[i]] + 
                tau[plot[i]];
        mu[i] = exp(mu[i]);
      }
    
      total_fruts ~ neg_binomial_2(mu, scale);  
    }
    
    generated quantities{
      vector[N] log_lik;
      vector[N] mu_1;
      array[N] int ppcheck;
    
      for (i in 1:N) {
        mu_1[i] = theta[plant_id[i]] + alpha[farm[i]] + 
                tau[plot[i]];
        mu_1[i] = exp(mu_1[i]);
      }
    
      for (i in 1:N) log_lik[i] = neg_binomial_2_lpmf(total_fruts[i] | mu_1[i], scale);
    
      ppcheck = neg_binomial_2_rng(mu_1, scale);
      
    }
    
    ")
```

### Running MCMC algorith and model's outputs

```{r, warning=FALSE, message=FALSE, error=FALSE}
file <- paste(getwd(), '/fruits_plant.stan', sep = '')

fit_fruit_plant <- cmdstan_model(file, compile = T)

mod_fruit_plant <- 
  fit_fruit_plant$sample(
    data = fruit_plant, 
    chains = 3, 
    parallel_chains = 3, 
    iter_sampling = 2e3, 
    iter_warmup = 500, 
    thin = 3, 
    seed = 123, 
    refresh = 500
  )

```


#### Model's diagnostics
```{r warning=FALSE, message=FALSE}

output_mod_tot_fru <- mod_fruit_plant$summary()

mod_diagnostics(mod_fruit_plant, output_mod_tot_fru)

trace_plot(mod_fruit_plant, output_mod_tot_fru$variable[1], 3)

par(mfrow = c(3, 3), mar = c(4, 4, 1, 1))
for (i in 2:10) trace_plot(mod_fruit_plant, output_mod_tot_fru$variable[i], 3)
par(mfrow = c(1, 1))

post_tot_fruit <- mod_fruit_plant$draws(format = 'df')

post_tot_fruit <- 
  list(plant = post_tot_fruit[, grep('theta', colnames(post_tot_fruit))],
       farm = post_tot_fruit[, grep('alpha', colnames(post_tot_fruit))], 
       plot = post_tot_fruit[, grep('tau', colnames(post_tot_fruit))], 
       scale = post_tot_fruit$scale)

```
Chain convergence ok and enough *ess* for all parameters. 

#### Model's ppcheck

```{r}
ppcheck_tot_fru <- mod_fruit_plant$draws(variables = 'ppcheck', format = 'matrix')

plot(density(ppcheck_tot_fru[1, ]), ylim = c(0, 0.00025), main = '', 
     xlab = 'Fruit produced per plant', lwd = 0.1)
for (i in 1:100) lines(density(ppcheck_tot_fru[i, ]), lwd = 0.1)
lines(density(fruit_plant$total_fruts), col = 'red', lwd = 2)

```

Ppcheck ok!

Extracting the posterior predictive distribution of fruits produced per blueberry bush.
```{r}
total_fruts <- as.vector(ppcheck_tot_fru)

plot(density(total_fruts), xlab = 'Fruits produced per\n blueberry bush', 
     lwd = 3, col = 'lightblue', main = '')

```

## Total fruits produced by the plant

```{r}
set.seed(123)
total_flowers <- 
  total_fruts + 
  (total_fruts * 
     (1-sample(fruit_set, length(total_fruts), T)))

total_flowers <- round(total_flowers)

par(mfrow = c(1, 2), mar = c(4, 4, 0.5, 0.5))
plot(density(total_flowers), main = '', 
     xlab = 'Flowers per blueberry bush', xlim = c(0, 20e3), 
     lwd = 4, col = 'lightblue') 
plot(density(rbeta(2e3, 6, 4)), 
     xlab = 'Flowering proportion', ylab = '',
     lwd = 4, col = 'lightblue', main = '')

```

# (ii) Hives and bees

## Quality of the hives
`hives_ha` simulate *N* hives with an specific colony population size, and proportion of foragers. 
```{r}
hives_ha <- function(n_hives = 25, # n hives to be simulated
                     mu_pop = 1e4, # mu parameter NegBin distribution (i.e. N bees per hive)
                     sigma_pop = 10, # dispersion parameter NegBin distribution. N Bees per hive
                     beta_1 = 2.5, # parameter 1 beta distribution. Proportion of foragers
                     beta_2 = 8, # parameter 1 beta distribution. Proportion of foragers
                     seed = 1){ # set seed to reproduce the analysis
  
  hive_ha <- n_hives # hives per ha
  
  set.seed(seed) 
  # Simulating the number of bees per hive j from the negative binomial distribution
  beehive_strength <- rnbinom(hive_ha, size = sigma_pop, mu = mu_pop)
  
  set.seed(seed)
  # Simulating the proportion of foragers per hive j from
  prop_foragers <- rbeta(hive_ha, beta_1, beta_2)
  
  set.seed(seed)
  # simulated foragers per hive j 
  foragers_bees <- round(beehive_strength * prop_foragers, hive_ha)
  
  return(foragers_bees)
}

```

```{r, fig.cap= 'Orange = high-quality hives; Lightblue = low-quality hives'}
par(mar = c(4.2, 4.2, 1, 1))

plot(density(hives_ha(1e3, mu_pop = 10e3)), main = '', 
     xlab = 'Foragers per hive', lwd = 2, col = 'lightblue')
lines(density(hives_ha(1e3, mu_pop = 20e3)), lwd = 2, 
     col = 'tan1')

```


# (iii) Foraging pattern of honeybees

Assuming 8 hr of daily pollinators activity, we estimated the effective daily hours that each bee in the colony will spend for actively visiting flowers. This is based on the average and SD values reported by [Eckert et al. (1994)](https://www.jstor.org/stable/4220612) (Table 3) for nectar and pollen foragers from small and large honeybee hives. We used those values to parametrize normal distributions:

```{r}
###### high quality hives 
 
# number of foraging trips within 90 min
trip_frequency_HQ <- rnorm(5e4, # high quality hives
                           mean(c(1.23, # nectar forager 
                                  1.21)), # pollen forager
                           mean(c(0.06, # nectar forager 
                                  0.15))) # pollen forager

# time span of a foraging trip (s)
trip_span_HQ <- rnorm(5e4, 
                      mean(c(1667.7, # nectar forager 
                             2683.9)), # pollen forager
                      mean(c(126.4, # nectar forager 
                             250.7))) # pollen forager

trips_bee_HQ <- 
  trip_frequency_HQ * ((8*60)/90) # number of trips per day

# dayly foraging time in seconds that a single bee from a high-quality hive 
# would invest visiting flowers.
foraging_time_HQ <- 
  trip_span_HQ * trips_bee_HQ 

###### low quality hives

# number of foraging trips within 90 min
trip_frequency_LQ <- rnorm(5e4, 
                           mean(c(1, 1.4)), # nectar forager 
                           mean(c(0, 0.16))) # pollen forager

# time span of a foraging trip (s)
trip_span_LQ <- rnorm(5e4, 
                      mean(c(1210.8, 1680.4)), # nectar forager 
                      mean(c(157.6, 212.6))) # pollen forager

trips_bee_LQ <- trip_frequency_LQ * ((8*60)/90) # number of trips per day

# dayly foraging time in seconds that a single bee from a low-quality hive 
# would invest visiting flowers.
foraging_time_LQ <- trip_span_LQ * trips_bee_LQ 

```

```{r, fig.cap= 'Orange = high-quality hives; Lightblue = low-quality hives'}
par(mfrow = c(2, 2), mar = c(4.2, 4.2, 1, 1))

plot(density(trip_frequency_HQ), col = 'tan1', main = '', ylim = c(0, 5.5),
     xlab = 'Number of foraging trips (trips/90 min)', lwd = 2)
lines(density(trip_frequency_LQ), col = 'lightblue', main = '',
      xlab = 'Number of foraging trips (trips/90 min)', lwd = 2)

plot(density(trip_span_HQ/60), col = 'tan1', main = '', xlim = c(10, 50),
     xlab = 'Trip span (min)', lwd = 2)
lines(density(trip_span_LQ/60), main = '', col = 'lightblue',
      xlab = 'Trip span (min)', lwd = 2)

plot(density(trips_bee_HQ), main = '', col = 'tan1',
     xlab = 'Daily trips per bee', lwd = 2, ylim = c(0, 1))
lines(density(trips_bee_LQ), main = '', col = 'lightblue',
      xlab = 'Daily trip per bee (min)', lwd = 2)

plot(density((foraging_time_HQ/60)/60), col = 'tan1', main = '', ylim = c(0, 1.1),
     xlab = 'Daily foraging time per bee (h)', lwd = 2, xlim = c(1, 6.5))
lines(density((foraging_time_LQ/60)/60), main = '', col = 'lightblue',
      xlab = 'Daily foraging time per bee (h)', lwd = 2)

```

## Time of floral visit

During the blueberry flowering season of 2019 and 2021 in Northwestern Argentina, we walked through the crop searching for individuals of honeybees to record, with a chronometer, the time span of floral visit. We conducted those walks during sunny days and favorable weather conditions.

## Data wrangling

```{r}
visit_span <- readRDS('honeybee_visit_span.rds')

visit_span <- visit_span$A_mellifera

length(visit_span) # sampling size (N independent records)

```

## Model time of floral visit

### Matematical version

$$
\begin{align}

& time~of~floral~visit_i \sim gamma(\frac{\mu_i}{\sigma}, \frac{1}{\sigma}) \\
& log(\mu_i) = \alpha_{individual~ i} \\
& \alpha_{individual~ i} = \mu_\alpha + Z_\alpha \times \sigma_\alpha \\
& \mu_\alpha \sim normal(5, 1.5) \\
& Z_\alpha \sim normal(0, 1) \\
& \sigma_\alpha \sim exponential(1) \\
\end{align}
$$

### Model in Stan code

```{r}
cat(file = 'honeybee_visit.stan', 
    '
    data{
      int N;
      vector[N] visit;
      array[N] int individual;
    }
    
    parameters{
      vector[N] z_alpha;
      real<lower = 0> mu;
      real<lower = 0> sigma;
      real<lower = 0> sigma1;
    }
    
    transformed parameters{
      vector[N] alpha;
      alpha = mu + z_alpha * sigma1;
    }
    
    model{
      vector[N] p;
      mu ~ normal(3, 0.5);
      sigma ~ exponential(3);
      sigma1 ~ exponential(1);
      z_alpha ~ normal(0, 1);
    
      for (i in 1:N) {
        p[i] = alpha[individual[i]];
        p[i] = exp(p[i]);
      }
      
      visit ~ gamma(p/sigma, 1/sigma);
    }
    
    generated quantities{
      vector[N] log_lik;
      vector[N] p;
      array[N] real ppcheck;
      
      for (i in 1:N) {
        p[i] = alpha[individual[i]];
        p[i] = exp(p[i]);
      }
    
      for (i in 1:N) log_lik[i] = gamma_lpdf(visit[i] | p[i]/sigma, 1/sigma);
    
      ppcheck = gamma_rng(p/sigma, 1/sigma);
    }
    ')

```

### Running MCMC algorith and model's outputs
```{r warning=FALSE, message=FALSE, error=FALSE}
file <- paste(getwd(), '/honeybee_visit.stan', sep = '')
fit_visit_honeybee <- cmdstan_model(file, compile = T)

mod_visit_honeybee <- 
  fit_visit_honeybee$sample(
    data = list(visit = visit_span, 
                N = length(visit_span), 
                individual = 1:length(visit_span)),
    iter_sampling = 30e3, 
    iter_warmup = 500, 
    chains = 3, 
    parallel_chains = 3, 
    thin = 3, 
    seed = 123, 
    refresh = 500
  )

```

#### Model's diagnostics
```{r}
(output_mod_visit_honeybee <- mod_visit_honeybee$summary())

mod_diagnostics(mod_visit_honeybee, output_mod_visit_honeybee)

par(mfrow = c(3, 3), mar = c(4, 4, 1, 1))
for (i in 1:9) trace_plot(mod_visit_honeybee, output_mod_visit_honeybee$variable[i], 3)
par(mfrow = c(1, 1))
```
Chain convergenceits ok 

#### Model's ppcheck
```{r}
ppcheck_visit_honeybee <- mod_visit_honeybee$draws(variables = 'ppcheck', 
                                                   format = 'matrix')

plot(density(ppcheck_visit_honeybee[1, ]), ylim = c(0, 0.09), lwd = 0.1, 
     main = '', xlab = 'Honeybee time of floral visit (s)')
for (i in 1:100) lines(density(ppcheck_visit_honeybee[i, ]), lwd = 0.1)
lines(density(visit_span), col = 'red', lwd = 2)

```
ppcheck ok!


#### Time of floral visit

Posterior predictive distribution of the time span of a honeybee visiting a blueberry flower (s).
```{r}
time_visit_honeybee <- as.vector(ppcheck_visit_honeybee)
par(mar = c(4, 4, 1, 1))
plot(density(time_visit_honeybee), col = 'tan1', lwd = 3, 
     main = '', xlab = 'Time span of floral visit (s)')
```

## Foraging trips per day

The purpose od `N_foraging_trips` function was using the distribution of hours spend visiting flowers daily, and the time of floral visits, to estimate the number of floral visits that a single honeybee can conduct daily. To do so, the functions conduct simulations of random time of floral visits until until complete the bee hours for foraging in a single day.

```{r}
# function to estimate the number of foraging trip per individual i in 
# hive j, depending on the quality of the hive.

N_foraging_trips <- 
  
  function(iter, # bees per hive 
           time_foragin, # effective time to forage during the day
           time_per_visit, # posterior distribution of time spend per visit
           seed = 123) { 
    
    set.seed(seed)
    # a honeybee i with a random  daily foraging time (hr) j
    time_foragin <- sample(time_foragin, iter, T)
    
    t1 <- Sys.time()
    visits_bee <- 
      sapply(1:iter, FUN = 
               # loop through each honeybee i with daily foraging time j
               function(x) {
                 
                 time <- 0
                 vis <- 0
                 
                 while (time < time_foragin[[x]]) {
                   # each honeybee i accumulates random floral visits with
                   # time span k (s) without surpassing its total foraging 
                   # time j.
                   time <- time + sample(time_per_visit, 1)
                   vis <- vis + 1
                 }
                 
                 vis  
                 # number of daily floral visits of the honeybee i with foraging
                 # time j
                 
               })
    message(paste('Execution time', Sys.time() - t1))
    
    return(visits_bee)
    
  }

```


```{r, fig.cap= 'Orange = high-quality hives; Lightblue = low-quality hives'}
# t1 <- Sys.time()
# visits_day <- N_foraging_trips(iter = 2e4, 
#                                time_foragin = foraging_time_LQ, 
#                                time_per_visit = time_visit_honeybee)
# Sys.time() - t1

visits_day <- readRDS('visits_day_LQ.rds')


# t1 <- Sys.time()
# visits_day_HQ <- N_foraging_trips(iter = 2e4, 
#                                time_foragin = foraging_time_HQ, 
#                                time_per_visit = time_visit_honeybee)
# Sys.time() - t1

visits_day_HQ <- readRDS('visits_day_HQ.rds')

plot(density(visits_day), main = '', xlab = 'Number of floral visits of\n a single forager honeybee bee per day',
     lwd = 4, col = 'lightblue', xlim = c(395, 2000))
lines(density(visits_day_HQ), lwd = 4, col = 'tan1')

```

# (iv) Floral visits and pollen deposition

## Honeybees single-visit pollen deposition to blueberry flowers

We conducted a field experiment to evaluate per-visit pollen deposition of honeybees. To do this, we placed nylon mesh bags over blueberry flowering branches with immature flowers to prevent pollen deposition by pollinators. When the flowers were fully open, we removed the bag, cut the branch and kept it fresh in water. We then walked through the crop to offer the virgin flowers to honeybees. After a single honeybee-visit, we isolated the flower, tagged it, and brought the flowering branches to the laboratory for a period of at least 12 hours to ensure that pollen grains had fully adhered to the stigma. We then collected the style and stored it in an Eppendorf tube containing 70% ethanol. In the laboratory, we did a transversal cut of the style at the stigma height and placed it on a microscope slide. We then covered the stigma with a drop of Alexander’s stain, crushed it with a coverslip and counted the pollen grains under a microscope.

## Data wrangling

```{r}
apisSVP <- readRDS('honeybee_svpd_data.rds')
```

```{r echo=FALSE}
apisSVP <- apisSVP[-which.max(apisSVP)] # removing value with 155 pollen deposition
```

```{r}
length(apisSVP) # sampling size

dat_apis <- list(pollen = apisSVP, 
                 N = length(apisSVP), 
                 ind_id = 1:length(apisSVP), 
                 N_ind = length(apisSVP))
```

## Model single-visit pollen deposition

### Matematical version

$$
\begin{align}

& Pollen~deposition_i \sim negative~binomial(\lambda_i, \sigma) \\
& log(\lambda_i) = \alpha_{individual~i} \\
& \alpha_{individual~i} = \mu_\alpha + Z_\alpha \times \sigma_\alpha \\
& \mu_\alpha \sim normal(3, 0.5) \\
& Z_\alpha \sim normal(0, 1) \\
& \sigma_\alpha \sim exponential(1) \\

\end{align}
$$
We used $\mu_\alpha \sim normal(3, 0.5)$ since it encompass the expected average pollen deposition during a single honeybee visit to blueberry flowers. We used a non-centered parametrization and partial pooling across individuals to estimate the parameters.

### Model in Stan code

```{r}
cat(file = 'model_apis_SVP.stan', 
    '
    data{
      int N;
      int N_ind;
      array[N] int pollen;
      array[N] int ind_id;
    }
    
    parameters{
      vector[N_ind] z_alpha;
      real mu;
      real<lower = 0> sigma;
      real<lower = 0> phi;
    }
    
    transformed parameters{
      vector[N_ind] alpha;
      alpha = mu + z_alpha * sigma;
    }
    
    model {
      vector[N] lambda;
      z_alpha ~ normal(0, 1);
      mu ~ normal(3, 0.5);
      sigma ~ exponential(1);
      phi ~ exponential(1);
      
      for (i in 1:N){
        lambda[i] = alpha[ind_id[i]];
        lambda[i] = exp(lambda[i]);
      }
      
      pollen ~ neg_binomial_2(lambda, phi);
    }
    
    generated quantities{
      vector[N] log_lik;
      array[N] int ppcheck;
      vector[N] lambda1;
    
      for (i in 1:N){
        lambda1[i] = alpha[ind_id[i]];
        lambda1[i] = exp(lambda1[i]);
      }
    
      for (i in 1:N) log_lik[i] = neg_binomial_2_lpmf(pollen[i] | lambda1[i], phi);
    
      ppcheck = neg_binomial_2_rng(lambda1, phi);
      
    }
    ')

```

### Running MCMC algorith and model's outputs

```{r, warning=FALSE, message=FALSE, error=FALSE}
file <- paste(getwd(), '/model_apis_SVP.stan', sep = '')
fit_apis_svp <- cmdstan_model(file, compile = T)

model_apis_svp <- 
  fit_apis_svp$sample(
    data = dat_apis, 
    chains = 3, 
    iter_sampling = 10e3, 
    iter_warmup = 500, 
    parallel_chains = 3, 
    thin = 3, 
    refresh = 200, 
    seed = 123
  )

```

### Model's diagnostics

```{r}
out_put_apis_svp <- model_apis_svp$summary()

mod_diagnostics(model_apis_svp, out_put_apis_svp)

model_apis_svp$summary()

par(mfrow = c(3, 3), mar = c(4, 4, 1, 1))
for (i in 1:9) trace_plot(model_apis_svp, out_put_apis_svp$variable[i], 3)
par(mfrow = c(1, 1))

```

### Model's ppcheck

```{r}
post_apis_svp <- model_apis_svp$draws(format = 'df')[-1]
post_apis_svp$mu <- exp(post_apis_svp$mu)

pp_check_svp <- model_apis_svp$draws(variables = 'ppcheck', format = 'matrix')
  
plot(density(pp_check_svp[1, ]), lwd = 0.1, main = '', 
     xlab = 'Single visit pollen deposition', ylim = c(0, 0.05))
for (i in 1:100) lines(density(pp_check_svp[i, ]), lwd = 0.1)
lines(density(dat_apis$pollen), col = 'red', lwd = 3)

```

## Rate of pollen accumulation after N honeybee visits

We used the the posterior predictive distribution of the model above to conduct simulations recreating the random process of pollen deposition during sequential honeybee visits. We ran 2000 simulations per honeybee visit, considering the visit as a factor with one to n levels. Each simulation can be considered as a flower —2000 flowers per honeybee visit level— whose stigmatic pollen load is the additive result of random pollen deposition after n honeybee visits. The purpose of this simulations was generate data to estimate the rate of increase of pollen deposition.

This simulation assume that pollen grains are added up at each sequential visit and no stigmatic pollen was removed in the process.


```{r}
set.seed(1234)
sim_visits <- 
  apply(pp_check_svp[c(sample(1:nrow(pp_check_svp), size = 100, replace = F)),], 1, 
        simplify = 'list', FUN = 
          # looping over posterior predictive distributions of single-visit
          # pollen deposition
          function(x) {
            
            df_2 <- tibble()
              
            for (j in 1:10) { # simulating ten consecutive visits 
              
              sum_vis <- 
                sapply(1:2e3, FUN = # 2000 samples per visit to
                         function(k) { # sum random values of pollen deposition
                           sum(sample(x, size = j, T))
                         })
              
              df_ <- tibble(poll_ac = sum_vis,
                            vis = j)
              
              df_2 <- rbind(df_2, df_)
              
            }
            df_2[sample(1:nrow(df_2), size = 200, replace = F), ]
          })

names(sim_visits) <- paste('sim', 1:length(sim_visits))

for (i in seq_along(sim_visits)) {
  sim_visits[[i]]$sim <- rep(paste('sim', i), nrow(sim_visits[[i]]))
}

sim_visits <- do.call('rbind', sim_visits)

sim_visits <- lapply(sim_visits[1:2], function(x) x)

sim_visits$N <- length(sim_visits$poll_ac)

sim_visits %$% plot(vis + rnorm(1e4, 0.1, 0.1), poll_ac, cex = 0.1, 
                    xlab = 'Number of honeybee visits', 
                    ylab = 'Pollen deposition', 
                    ylim = c(0, 600))
points(1:10, 
       tapply(sim_visits$poll_ac, sim_visits$vis, FUN = mean), 
       col = 'red', pch = 15)
abline(h = c(112, 274), lty = 2, col = 'red')
text(x = 2, y = 300, 'Optimal pollination')

```

We use this simulate data to estimate the rate of increase (i.e. slope in a linear model). It will be used to parametrize an asymptotic exponential function to predict pollen deposition in blueberry flowers after *N* honeybee visits.

Lest estimate the slope using a model

```{r, eval =FALSE}

cat(file = 'slope_svp_apis.stan', 
    '
    data{
      int N;
      array[N] int poll_ac;
      array[N] int vis;
    }
    
    parameters{
      real alpha;
      real beta;
      real<lower = 0> sigma;
    }
    
    model{
      vector[N] lambda;
      alpha ~ normal(20, 5);
      beta ~ normal(3, 0.5);
      sigma ~ exponential(1);
    
      for (i in 1:N) {
        lambda[i] = alpha + beta*vis[i];
        lambda[i] = exp(lambda[i]);
      }
    
      poll_ac ~ neg_binomial_2(lambda, sigma);
    }
    
    generated quantities{
      vector[N] lambda1;
      array[N] int ppcheck;
      vector[N] log_lik;
     
      for (i in 1:N) {
        lambda1[i] = alpha + beta*vis[i];
        lambda1[i] = exp(lambda1[i]);
      }
    
      for (i in 1:N) log_lik[i] = neg_binomial_2_lpmf(poll_ac[i] | lambda1[i], sigma);
    
      ppcheck = neg_binomial_2_rng(lambda1, sigma);
    }
    
    ')

file <- paste(getwd(), '/slope_svp_apis.stan', sep = '')

fit_svp_slope <- cmdstan_model(file, compile = T)

mod_svp_slope <- 
  fit_svp_slope$sample(
    data = sim_visits, 
    chains = 3,
    parallel_chains = 3, 
    iter_sampling = 2e3, 
    iter_warmup = 500, 
    thin = 3,
    refresh = 200, 
    seed = 123
  )

```

```{r}

mod_svp_slope <- readRDS('mod_svp_slope.rds')

post_svp_slope <- mod_svp_slope$draws(variables = c('alpha', 'beta'), format = 'df')

ppcheck_slope <- 
  sapply(1:length(sim_visits$vis), FUN = 
           function(i) {
             
             x <- sim_visits$vis[i]
             
             lambda <- 
               post_svp_slope$alpha +
               post_svp_slope$beta*x
             
             rnbinom(100, 
                     mu = exp(lambda),
                     size = post_svp_slope$alpha)
           })

plot(NULL, lwd = 0.1, main = '', 
     xlab = 'Single visit pollen deposition', 
     xlim = c(0, 600), ylim = c(0, 0.007), ylab = 'Density')
for (i in 1:50) lines(density(ppcheck_slope[i, ]), lwd = 0.1)
lines(density(sim_visits$poll_ac), col = 'red')

```

ppcheck ok!

```{r}

```


# (v) Final crop yield

