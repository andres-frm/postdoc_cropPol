---
title: "How much is enough? Optimizing beehive stocking densities to maximize the production of a pollinator-dependent crop"
subtitle: 'Appendix S1. Journal: Ecological Applications'
author: "Andrés F. Ramírez-Mejía"
format: 
  html:
    theme: 
      light: journal
      dark: [journal, theme-dark.scss]
    toc: true
    toc-depth: 10
    toc-expand: 10
    toc-title: "Content"
    toc-location: left
    embed-resources: true
number-sections: true
number-depth: 10
mainfont: Times New Roman
code-fold: false
code-overflow: scroll
code-line-numbers: true
code-copy: true
---

This document reproduces the data wrangling, modelling and simulations from *Ramírez-Mejía et al. How much is enough? Optimizing beehive stocking densities to maximize the production of a pollinator-dependent crop*. I provided  annotations along the entire script, with emphasizing on the modelling and simulations sections. Also, in order to facilitate reading the script, I organized it in the same order of the simulation phases: **(i)** the scenario, **(ii)** hives and bees, **(iii)** foraging pattern of honeybees, **(iv)** floral visits and pollen deposition, and **(v)** final crop yield.

# (i) The scenario

## Data pollination exclusion experiments

### Northwestern Region of Argentina
During two years, we did pollinator exclusion experiments in  nine blueberry farms with an average separation of 9.5 km between contiguous farms. Each experiment consisted of two flowering branch per plant (15 plants per farm, N = 135), where we recorded the number of flowers setting fruit. One branch was surrounded with a nylon bag to prevent pollinators visiting flowers while the other remained open to animal pollination. We used the Emerald cultivar in all experiments.

### Central Region of Argentina

Pablo...

## Data wrangling

The following code read into `R` and merge both data sets in a list object `dat_fs`. This is the data structure needed to fit the following Bayesian model.

```{r results='hide', message=FALSE, warning=FALSE}
pks <- c('tidyverse', 'rethinking', 'rstan', 'magrittr', 'cmdstanr',
         'ggdag', 'dagitty', 'readxl', 'brms', 'cowplot', 'parallel', 
         'compiler', 'KneeArrower')

sapply(pks, library, character.only = T)

options(mc.core = parallel::detectCores())

source('functions_mod_diagnostics.r') 
# this is an script to load functions for bayesian model diagnostics
```

```{r}
dat_fs <- readRDS('fruit_set.rds')

dat_fs <- dat_fs[, c("plant_id", "farm_id", "year_id",
                     "beehive", "treatment", "flowers", "fruits")]

dat_fs$treatment <- ifelse(dat_fs$treatment == 1, 'close', 'open')

dat_fs2 <- lapply(6:7, 
                  function(x) {
                    t <- read_xlsx('tesis_pablo.xlsx', 
                                   shee = x, 
                                   col_names = T, 
                                   na = 'NA')[, 1:5]
                    
                    t$locality <- 'entre_rios'
                    t$treatment <- 'open'
                    
                    colnames(t) <- c('farm_id', 'plant_id', 'branch_id',
                                     'flowers', 'fruits', 'locality_id', 
                                     'treatment')

                    t$branch_id <- t %$% paste(farm_id,
                                              plant_id,
                                              branch_id,
                                              sep = '')

                    t$plant_id <- t %$% paste(farm_id,
                                              plant_id,
                                              sep = '')
                    
                    t
                  })

names(dat_fs2) <- paste('y', c(2016, 2021), sep = '')
dat_fs2$y2016$year_id <- '2016'
dat_fs2$y2021$year_id <- '2021'

dat_fs$branch_id <- 1
dat_fs$locality_id <- 'tucuman'


dat_fs <- dat_fs[, c("farm_id", "plant_id", 
                     'branch_id', "flowers", 
                     "fruits", "locality_id", 
                     "treatment", "year_id")]

dat_fs$branch_id <- paste(dat_fs$farm_id, dat_fs$plant_id, 
                          dat_fs$branch_id, sep = '_')
dat_fs$plant_id <- paste(dat_fs$farm_id, 
                         dat_fs$plant_id, sep = '_')


dat_fs <- rbind(dat_fs, dat_fs2$y2016, dat_fs2$y2021)

dat_fs <- na.omit(dat_fs)

dat_fs <- 
  lapply(dat_fs, 
         function(x) {
           if (is.character(x)) as.numeric(as.factor(x))
           else x
         })

unlist(lapply(dat_fs, function(x) sum(is.na(x))))

dat_fs$N <- length(dat_fs$plant_id)
dat_fs$N_site <- length(unique(dat_fs$locality_id))
dat_fs$N_farm <- length(unique(dat_fs$farm_id))
dat_fs$N_plant <- length(unique(dat_fs$plant_id))
dat_fs$N_branch <- length(unique(dat_fs$branch_id))
dat_fs$N_treatment <- length(unique(dat_fs$treatment))
dat_fs$N_year <- length(unique(dat_fs$year_id))

```

## Model 1: probability of blueberry flowers setting fruit

### Matematical version

$$

\begin{align}

& fruits~produced_i \sim binomial(n~sampled~flowers_i, ~p_i)\\
& logit(p_i) = \alpha_{treatment_i} + \theta_{[plant_i, treatmen_i]} + \\ 
& \delta_{[farm_i, treatment_i]} + \lambda_{[region_i, treatment_i]} + \gamma_{[year_i, treatment_i]} \\
& \alpha_{treatment} \sim normal(0, 1) \\
& \theta_{[plant_i, treatmen_i]}  = (diag(\sigma_\theta), R_{cholesky~\theta}Z_\theta)^T \\
& \delta_{[farm_i, treatment_i]} = (diag(\sigma_\delta), R_{cholesky~\delta}Z_\delta)^T \\
& \lambda_{[region_i, treatment_i]} = (diag(\sigma_\lambda), R_{cholesky~\lambda}Z_\lambda)^T \\
& \gamma_{[year_i, treatment_i]} = (diag(\sigma_\gamma), R_{cholesky~\gamma}Z_\gamma)^T \\
& \sigma_\theta \sim exponential(1) \\
& \sigma_\delta \sim exponential(1) \\
& \sigma_\lambda \sim exponential(1) \\
& \sigma_\gamma \sim exponential(1) \\
& R_{cholesky~\theta} \sim LKJCorr(2) \\
& R_{cholesky~\delta} \sim LKJCorr(2) \\
& R_{cholesky~lambda} \sim LKJCorr(2) \\
& R_{cholesky~\gamma} \sim LKJCorr(2) \\
& Z_\theta \sim normal(0, 0.5) \\
& Z_\delta \sim normal(0, 0.5) \\
& Z_\lambda \sim normal(0, 0.5) \\
& Z_\gamma \sim normal(0, 0.5) \\

\end{align}

$$
We used $\alpha_{treatment} \sim normal(0, 1)$ as intercept, with a 
parametrization covering values from $-3.4$ to $3.4$ in the logit scales, which
basically implies all possible values in a probability scale. $LKJCorr(2)$ set 
values from $-1$ to $1$ for the probability distribution of correlations. $exponential(1)$ and $normal(0, 0.5)$ set standard priors for the dispersion and groupl-level effects parameters. We fitted the model using a non-centered parametrization.

### Model in Stan code

```{r eval=FALSE, echo=TRUE}
cat(file = 'fruit_set.stan', 
    "
    data{
      int N;
      int N_site;
      int N_farm;
      int N_plant;
      //int N_branch;
      int N_treatment;
      int N_year;
      array[N] int flowers;
      array[N] int fruits;
      array[N] int year_id;
      array[N] int locality_id;
      array[N] int farm_id;
      array[N] int plant_id;
      //array[N] int branch_id;
      array[N] int treatment;
    }
    
    parameters{
      vector[N_treatment] t;
      
      matrix[N_treatment, N_year] Z_year;
      cholesky_factor_corr[N_treatment] R_year;
      vector<lower = 0>[N_treatment] sigma_year;
      
      matrix[N_treatment, N_site] Z_locality;
      cholesky_factor_corr[N_treatment] R_locality;
      vector<lower = 0>[N_treatment] sigma_locality;
    
      matrix[N_treatment, N_farm] Z_farm;
      cholesky_factor_corr[N_treatment] R_farm;
      vector<lower = 0>[N_treatment] sigma_farm;
    
      matrix[N_treatment, N_plant] Z_plant;
      cholesky_factor_corr[N_treatment] R_plant;
      vector<lower = 0>[N_treatment] sigma_plant;
      
      //vector[N_branch] branch;
      
    }
    
    transformed parameters{
      matrix[N_year, N_treatment] year;
      matrix[N_site, N_treatment] locality;
      matrix[N_farm, N_treatment] farm;
      matrix[N_plant, N_treatment] plant;
    
      year = (diag_pre_multiply(sigma_year, R_year) * Z_year)';
      locality = (diag_pre_multiply(sigma_locality, R_locality) * Z_locality)';
      farm = (diag_pre_multiply(sigma_farm, R_farm) * Z_farm)';
      plant = (diag_pre_multiply(sigma_plant, R_plant) * Z_plant)';
    }
    
    model{
      vector[N] p;
      t ~ normal(0, 1);
    
      to_vector(Z_year) ~ normal(0, 0.5);
      R_year ~ lkj_corr_cholesky(2);
      sigma_year ~ exponential(1);
    
      to_vector(Z_locality) ~ normal(0, 0.5);
      R_locality ~ lkj_corr_cholesky(2);
      sigma_locality ~ exponential(1);
    
      to_vector(Z_farm) ~ normal(0, 0.5);
      R_farm ~ lkj_corr_cholesky(2);
      sigma_farm ~ exponential(1);
    
      to_vector(Z_plant) ~ normal(0, 0.5);
      R_plant ~ lkj_corr_cholesky(2);
      sigma_plant ~ exponential(1);
      //branch ~ normal(0, 1);
    
      for (i in 1:N) {
        p[i] = t[treatment[i]] + 
                locality[locality_id[i], treatment[i]] + 
                farm[farm_id[i], treatment[i]] +
                plant[plant_id[i], treatment[i]] +
                year[year_id[i], treatment[i]]; 
        
        p[i] = inv_logit(p[i]);
      }
      
      fruits ~ binomial(flowers, p);
    }
    
    generated quantities{
      vector[N] log_lik;
      vector[N] p1;
      array[N] int ppcheck;
      matrix[N_treatment, N_treatment] Rho_year;
      matrix[N_treatment, N_treatment] Rho_locality;
      matrix[N_treatment, N_treatment] Rho_farm;
      matrix[N_treatment, N_treatment] Rho_plant;
    
      Rho_year = multiply_lower_tri_self_transpose(R_year);
      Rho_locality = multiply_lower_tri_self_transpose(R_locality);
      Rho_farm = multiply_lower_tri_self_transpose(R_farm);
      Rho_plant = multiply_lower_tri_self_transpose(R_plant);
    
      for (i in 1:N) {
        p1[i] = t[treatment[i]] + 
                locality[locality_id[i], treatment[i]] + 
                farm[farm_id[i], treatment[i]] +
                plant[plant_id[i], treatment[i]] +
                year[year_id[i], treatment[i]]; 
        
        p1[i] = inv_logit(p1[i]);
      }
      
      for (i in 1:N) log_lik[i] = binomial_lpmf(fruits[i] | flowers[i], p1[i]);
    
      ppcheck = binomial_rng(flowers, p1);
    }
    ")

```

### Running MCMC algorith and model's outputs

```{r eval = F}
file <- paste(getwd(), '/fruit_set.stan', sep = '')

fit_fruit_set <- cmdstan_model(file, compile = T)

mod_fs_exp <- 
  fit_fruit_set$sample(
    data = dat_fs, 
    chains = 3, 
    parallel_chains = 3, 
    iter_warmup = 500, 
    iter_sampling = 4e3,
    thin = 3,
    seed = 123,
    refresh = 500
  )
```


#### Model's diagnostics
```{r warning=FALSE, message=FALSE}

mod_fs_exp <- readRDS('mod_blueberry_fs.rds')

output_mod_fruitset <- mod_fs_exp$summary() 

mod_diagnostics(mod_fs_exp, output_mod_fruitset)

par(mfrow = c(3, 3), mar = c(4, 4, 1, 1))
for (i in 2:10) {
  trace_plot(mod_fs_exp, output_mod_fruitset$variable[i], 3)
}
par(mfrow = c(1, 1))

post_fruitset <- mod_fs_exp$draws(format = 'df')

post_fruitset <- as.matrix(post_fruitset)

```
Chain convergence ok and enough *ess* for all parameters. We had some observations with high pareto-k values, but, as you can see below, the model predicts well the observed data.

#### Model's ppcheck

```{r}
post_fruitset <- 
  list(treatment = post_fruitset[, grep('^t', colnames(post_fruitset))], 
       locality = post_fruitset[, grep('^locality', colnames(post_fruitset))], 
       farm = post_fruitset[, grep('^farm', colnames(post_fruitset))], 
       plant = post_fruitset[, grep('^plant', colnames(post_fruitset))],
       year = post_fruitset[, grep('^year', colnames(post_fruitset))])

ppcheck_fruit_set <- mod_fs_exp$draws(variables = 'ppcheck', format = 'matrix')

plot(density(ppcheck_fruit_set[1, ]), ylim = c(0, 0.025), lwd = 0.1, 
     main = '', xlab = 'Number of fruit')
for (i in 1:100) lines(density(ppcheck_fruit_set[i, ]), lwd = 0.1)
lines(density(dat_fs$fruits), col = 'red', lwd = 2)
```

ppcheck ok!

Extracting the marginalized posterior distribution of flowers setting fruit in open pollination treatment.
```{r}
fruit_set <- 
  inv_logit(
    post_fruitset$treatment[, 2, drop = T] +
      apply(post_fruitset$locality, 1, mean) + 
      apply(post_fruitset$farm, 1, mean) +
      apply(post_fruitset$plant, 1, mean) +
      apply(post_fruitset$year, 1, mean) 
  )

plot(density(fruit_set), main = '', 
     xlab = 'Probability of blueberry\n flowers setting fruit', col = 'lightblue', lwd = 4)

```

## Data fruits production per plant

During the 2021 production season of the Northwestern Argentina, we use three farms to estimate the number of fruits produced by blueberry bushes. At each farm we chose five to six plots (Emerald cultivar, plot size $1.31~\pm~0.09~ha$ 0.09 ha) distributed from the farm border to interior to encompass potential variation in underlying pollination services, soil condition, irrigation system and plant age. The average nearest distance among plots was $384.4~\pm~197.5~m$. At each location we randomly selected five plants and counted the total number of fruits on two randomly chosen primary branches. The product of the average number of fruits per primary branch and number of primary branches was used as an estimate of total fruits produced by the plant.

## Data wrangling

```{r}
fruit_plant <- readRDS('fruit_plant.rds')

fruit_plant$plant_id <- as.factor(paste(fruit_plant$farm, fruit_plant$plant, sep = '_'))

fruit_plant$plot <- as.factor(paste(fruit_plant$farm, fruit_plant$plot, sep = '_'))

fruit_plant <- fruit_plant[, c("farm", "plot", 'plant_id', "total_fruts")]

fruit_plant <- lapply(fruit_plant, function(x) if(is.factor(x)) as.numeric(x) else(x))

fruit_plant$N <- length(fruit_plant$farm)
fruit_plant$N_farm <- length(unique(fruit_plant$farm))
fruit_plant$N_plot <- length(unique(fruit_plant$plot))
fruit_plant$N_plant <- length(unique(fruit_plant$plant))
fruit_plant$total_fruts <- round(fruit_plant$total_fruts)
```

## Model 2: number of fruits produced by a blueberry bush

### Matematical version

$$
\begin{align}

& Total~fruit~bush_i \sim negative~binomial(\lambda_i, \sigma) \\
& log(\lambda_i) = \alpha_{plant~i} + \theta_{plot~i} + \delta_{farm~i} \\
& \alpha_{plant~i} = \mu_\alpha + Z_\alpha \times \sigma_\alpha \\
& \theta_{plot~i} = \mu_\theta + Z_\theta \times \sigma_\theta \\
& \delta_{farm~i} = \mu_\delta + Z_\delta \times \sigma_\delta \\
& \mu_\alpha \sim normal(7, 2) \\
& \mu_\theta \sim normal(0, 1) \\
& \mu_\delta \sim normal(0, 1) \\
& Z_\alpha \sim normal(0, 1) \\
& Z_\theta \sim normal(0, 1) \\
& Z_\delta \sim normal(0, 1) \\
& \sigma_\alpha \sim exponential(1) \\
& \sigma_\theta \sim exponential(1) \\
& \sigma_\delta \sim exponential(1) \\

\end{align}
$$
We used the $plant_i$ as the model's intercept, so the exponentiation of $normal(7, 2)$ denotes the expected average number of number of fruits per blueberry bush ($\lambda_i$ parameter). We used a non-centered parametrization to fit the model.

### Model in Stan code

```{r eval=T}
cat(file = 'fruits_plant.stan', 
    "
    data{
      int N;
      int N_farm;
      int N_plot;
      int N_plant;
      array[N] int plant_id;
      array[N] int total_fruts;
      array[N] int farm;
      array[N] int plot;
    }
    
    parameters{
      vector[N_plant] z_plant;
      real mu_plant;
      real<lower = 0> sigma_plant;
    
      vector[N_farm] z_farm;
      real mu_farm;
      real<lower = 0> sigma_farm;
    
      vector[N_plot] z_plot;
      real mu_plot;
      real<lower = 0> sigma_plot;
    
      real<lower = 0> scale;
    }
    
    transformed parameters{
      vector[N_plant] theta;
      vector[N_farm] alpha;
      vector[N_plot] tau;
      theta = mu_plant + z_plant * sigma_plant;
      alpha = mu_farm + z_farm * sigma_farm;
      tau = mu_plot + z_plot * sigma_plot;
      
    }
    
    model{
      vector[N] mu;
    
      mu_plant ~ normal(7, 2);
      z_plant ~ normal(0, 1);
      sigma_plant ~ exponential(1);
    
      mu_farm ~ normal(0, 1);
      z_farm ~ normal(0, 1);
      sigma_farm ~ exponential(1);
      
      mu_plot ~ normal(0, 1);
      z_plot ~ normal(0, 1);
      sigma_plot ~ exponential(1);
    
      scale ~ exponential(1);
    
      for (i in 1:N) {
        mu[i] = theta[plant_id[i]] + alpha[farm[i]] + 
                tau[plot[i]];
        mu[i] = exp(mu[i]);
      }
    
      total_fruts ~ neg_binomial_2(mu, scale);  
    }
    
    generated quantities{
      vector[N] log_lik;
      vector[N] mu_1;
      array[N] int ppcheck;
    
      for (i in 1:N) {
        mu_1[i] = theta[plant_id[i]] + alpha[farm[i]] + 
                tau[plot[i]];
        mu_1[i] = exp(mu_1[i]);
      }
    
      for (i in 1:N) log_lik[i] = neg_binomial_2_lpmf(total_fruts[i] | mu_1[i], scale);
    
      ppcheck = neg_binomial_2_rng(mu_1, scale);
      
    }
    
    ")
```

### Running MCMC algorith and model's outputs

```{r, warning=FALSE, message=FALSE, error=FALSE}
file <- paste(getwd(), '/fruits_plant.stan', sep = '')

fit_fruit_plant <- cmdstan_model(file, compile = T)

mod_fruit_plant <- 
  fit_fruit_plant$sample(
    data = fruit_plant, 
    chains = 3, 
    parallel_chains = 3, 
    iter_sampling = 2e3, 
    iter_warmup = 500, 
    thin = 3, 
    seed = 123, 
    refresh = 500
  )

```


#### Model's diagnostics
```{r warning=FALSE, message=FALSE}

output_mod_tot_fru <- mod_fruit_plant$summary()

mod_diagnostics(mod_fruit_plant, output_mod_tot_fru)

trace_plot(mod_fruit_plant, output_mod_tot_fru$variable[1], 3)

par(mfrow = c(3, 3), mar = c(4, 4, 1, 1))
for (i in 2:10) trace_plot(mod_fruit_plant, output_mod_tot_fru$variable[i], 3)
par(mfrow = c(1, 1))

post_tot_fruit <- mod_fruit_plant$draws(format = 'df')

post_tot_fruit <- 
  list(plant = post_tot_fruit[, grep('theta', colnames(post_tot_fruit))],
       farm = post_tot_fruit[, grep('alpha', colnames(post_tot_fruit))], 
       plot = post_tot_fruit[, grep('tau', colnames(post_tot_fruit))], 
       scale = post_tot_fruit$scale)

```
Chain convergence ok and enough *ess* for all parameters. 

#### Model's ppcheck

```{r}
ppcheck_tot_fru <- mod_fruit_plant$draws(variables = 'ppcheck', format = 'matrix')

plot(density(ppcheck_tot_fru[1, ]), ylim = c(0, 0.00025), main = '', 
     xlab = 'Fruit produced per plant', lwd = 0.1)
for (i in 1:100) lines(density(ppcheck_tot_fru[i, ]), lwd = 0.1)
lines(density(fruit_plant$total_fruts), col = 'red', lwd = 2)

```

Ppcheck ok!

Extracting the posterior predictive distribution of fruits produced per blueberry bush.
```{r}
total_fruts <- as.vector(ppcheck_tot_fru)

plot(density(total_fruts), xlab = 'Fruits produced per\n blueberry bush', 
     lwd = 3, col = 'lightblue', main = '')

```

## Total fruits produced by the plant

```{r}
set.seed(123)
total_flowers <- 
  total_fruts + 
  (total_fruts * 
     (1-sample(fruit_set, length(total_fruts), T)))

total_flowers <- round(total_flowers)

par(mfrow = c(1, 2), mar = c(4, 4, 0.5, 0.5))
plot(density(total_flowers), main = '', 
     xlab = 'Flowers per blueberry bush', xlim = c(0, 20e3), 
     lwd = 4, col = 'lightblue') 
plot(density(rbeta(2e3, 6, 4)), 
     xlab = 'Flowering proportion', ylab = '',
     lwd = 4, col = 'lightblue', main = '')

```

# (ii) Hives and bees

## Quality of the hives
`hives_ha` simulate *N* hives with an specific colony population size, and proportion of foragers. 
```{r}
hives_ha <- function(n_hives = 25, # n hives to be simulated
                     mu_pop = 1e4, # mu parameter NegBin distribution (i.e. N bees per hive)
                     sigma_pop = 10, # dispersion parameter NegBin distribution. N Bees per hive
                     beta_1 = 2.5, # parameter 1 beta distribution. Proportion of foragers
                     beta_2 = 8, # parameter 1 beta distribution. Proportion of foragers
                     seed = 1){ # set seed to reproduce the analysis
  
  hive_ha <- n_hives # hives per ha
  
  set.seed(seed) 
  # Simulating the number of bees per hive j from the negative binomial distribution
  beehive_strength <- rnbinom(hive_ha, size = sigma_pop, mu = mu_pop)
  
  set.seed(seed)
  # Simulating the proportion of foragers per hive j from
  prop_foragers <- rbeta(hive_ha, beta_1, beta_2)
  
  set.seed(seed)
  # simulated foragers per hive j 
  foragers_bees <- round(beehive_strength * prop_foragers, hive_ha)
  
  return(foragers_bees)
}

```

```{r, fig.cap= 'Orange = high-quality hives; Lightblue = low-quality hives'}
par(mar = c(4.2, 4.2, 1, 1))

plot(density(hives_ha(1e3, mu_pop = 10e3)), main = '', 
     xlab = 'Foragers per hive', lwd = 2, col = 'lightblue')
lines(density(hives_ha(1e3, mu_pop = 20e3)), lwd = 2, 
     col = 'tan1')

```

## Foraging pattern of honeybees

Assuming 8 hr of daily pollinators activity, we estimated the effective daily hours that each bee in the colony will spend for actively visiting flowers. This is based on the average and SD values reported by [Eckert et al. (1994)](https://www.jstor.org/stable/4220612) (Table 3) for nectar and pollen foragers from small and large honeybee hives. We used those values to parametrize normal distributions:

```{r}
###### high quality hives 
 
# number of foraging trips within 90 min
trip_frequency_HQ <- rnorm(5e4, # high quality hives
                           mean(c(1.23, # nectar forager 
                                  1.21)), # pollen forager
                           mean(c(0.06, # nectar forager 
                                  0.15))) # pollen forager

# time span of a foraging trip (s)
trip_span_HQ <- rnorm(5e4, 
                      mean(c(1667.7, # nectar forager 
                             2683.9)), # pollen forager
                      mean(c(126.4, # nectar forager 
                             250.7))) # pollen forager

trips_bee_HQ <- 
  trip_frequency_HQ * ((8*60)/90) # number of trips per day

# dayly foraging time in seconds that a single bee from a high-quality hive 
# would invest visiting flowers.
foraging_time_HQ <- 
  trip_span_HQ * trips_bee_HQ 

###### low quality hives

# number of foraging trips within 90 min
trip_frequency_LQ <- rnorm(5e4, 
                           mean(c(1, 1.4)), # nectar forager 
                           mean(c(0, 0.16))) # pollen forager

# time span of a foraging trip (s)
trip_span_LQ <- rnorm(5e4, 
                      mean(c(1210.8, 1680.4)), # nectar forager 
                      mean(c(157.6, 212.6))) # pollen forager

trips_bee_LQ <- trip_frequency_LQ * ((8*60)/90) # number of trips per day

# dayly foraging time in seconds that a single bee from a low-quality hive 
# would invest visiting flowers.
foraging_time_LQ <- trip_span_LQ * trips_bee_LQ 

```

```{r, fig.cap= 'Orange = high-quality hives; Lightblue = low-quality hives'}
par(mfrow = c(2, 2), mar = c(4.2, 4.2, 1, 1))

plot(density(trip_frequency_HQ), col = 'tan1', main = '', ylim = c(0, 5.5),
     xlab = 'Number of foraging trips (trips/90 min)', lwd = 2)
lines(density(trip_frequency_LQ), col = 'lightblue', main = '',
      xlab = 'Number of foraging trips (trips/90 min)', lwd = 2)

plot(density(trip_span_HQ/60), col = 'tan1', main = '', xlim = c(10, 50),
     xlab = 'Trip span (min)', lwd = 2)
lines(density(trip_span_LQ/60), main = '', col = 'lightblue',
      xlab = 'Trip span (min)', lwd = 2)

plot(density(trips_bee_HQ), main = '', col = 'tan1',
     xlab = 'Daily trips per bee', lwd = 2, ylim = c(0, 1))
lines(density(trips_bee_LQ), main = '', col = 'lightblue',
      xlab = 'Daily trip per bee (min)', lwd = 2)

plot(density((foraging_time_HQ/60)/60), col = 'tan1', main = '', ylim = c(0, 1.1),
     xlab = 'Daily foraging time per bee (h)', lwd = 2, xlim = c(1, 6.5))
lines(density((foraging_time_LQ/60)/60), main = '', col = 'lightblue',
      xlab = 'Daily foraging time per bee (h)', lwd = 2)

```

## Time of floral visit

During the blueberry flowering season of 2019 and 2021 in Northwestern Argentina, we walked through the crop searching for individuals of honeybees to record, with a chronometer, the time span of floral visit. We conducted those walks during sunny days and favorable weather conditions.

## Data wrangling

```{r}
visit_span <- readRDS('honeybee_visit_span.rds')

visit_span <- visit_span$A_mellifera

length(visit_span) # sampling size (N independent records)

```

## Model time of floral visit

## Matematical model

$$
\begin{align}

& time~of~floral~visit_i \sim gamma(\frac{\mu_i}{\sigma}, \frac{1}{\sigma}) \\
& log(\mu_i) = \alpha_{individual~ i} \\
& \alpha_{individual~ i} = \mu_\alpha + Z_\alpha \times \sigma_\alpha \\
& \mu_\alpha \sim normal(5, 1.5) \\
& Z_\alpha \sim normal(0, 1) \\
& \sigma_\alpha \sim exponential(1) \\
\end{align}
$$

## Model in Stan code

```{r}
cat(file = 'honeybee_visit.stan', 
    '
    data{
      int N;
      vector[N] visit;
      array[N] int individual;
    }
    
    parameters{
      vector[N] z_alpha;
      real<lower = 0> mu;
      real<lower = 0> sigma;
      real<lower = 0> sigma1;
    }
    
    transformed parameters{
      vector[N] alpha;
      alpha = mu + z_alpha * sigma1;
    }
    
    model{
      vector[N] p;
      mu ~ normal(3, 0.5);
      sigma ~ exponential(3);
      sigma1 ~ exponential(1);
      z_alpha ~ normal(0, 1);
    
      for (i in 1:N) {
        p[i] = alpha[individual[i]];
        p[i] = exp(p[i]);
      }
      
      visit ~ gamma(p/sigma, 1/sigma);
    }
    
    generated quantities{
      vector[N] log_lik;
      vector[N] p;
      array[N] real ppcheck;
      
      for (i in 1:N) {
        p[i] = alpha[individual[i]];
        p[i] = exp(p[i]);
      }
    
      for (i in 1:N) log_lik[i] = gamma_lpdf(visit[i] | p[i]/sigma, 1/sigma);
    
      ppcheck = gamma_rng(p/sigma, 1/sigma);
    }
    ')

```

### Running MCMC algorith and model's outputs
```{r warning=FALSE, message=FALSE, error=FALSE}
file <- paste(getwd(), '/honeybee_visit.stan', sep = '')
fit_visit_honeybee <- cmdstan_model(file, compile = T)

mod_visit_honeybee <- 
  fit_visit_honeybee$sample(
    data = list(visit = visit_span, 
                N = length(visit_span), 
                individual = 1:length(visit_span)),
    iter_sampling = 30e3, 
    iter_warmup = 500, 
    chains = 3, 
    parallel_chains = 3, 
    thin = 3, 
    seed = 123, 
    refresh = 500
  )

```

#### Model's diagnostics
```{r}
(output_mod_visit_honeybee <- mod_visit_honeybee$summary())

mod_diagnostics(mod_visit_honeybee, output_mod_visit_honeybee)

par(mfrow = c(3, 3), mar = c(4, 4, 1, 1))
for (i in 1:9) trace_plot(mod_visit_honeybee, output_mod_visit_honeybee$variable[i], 3)
par(mfrow = c(1, 1))
```
Chain convergenceits ok 

#### Model's ppcheck
```{r}
ppcheck_visit_honeybee <- mod_visit_honeybee$draws(variables = 'ppcheck', 
                                                   format = 'matrix')

plot(density(ppcheck_visit_honeybee[1, ]), ylim = c(0, 0.09), lwd = 0.1, 
     main = '', xlab = 'Honeybee time of floral visit (s)')
for (i in 1:100) lines(density(ppcheck_visit_honeybee[i, ]), lwd = 0.1)
lines(density(visit_span), col = 'red', lwd = 2)

```
ppcheck ok!


#### Time of floral visit

Posterior predictive distribution of the time span of a honeybee visiting a blueberry flower (s).
```{r}
time_visit_honeybee <- as.vector(ppcheck_visit_honeybee)
par(mar = c(4, 4, 1, 1))
plot(density(time_visit_honeybee), col = 'tan1', lwd = 3, 
     main = '', xlab = 'Time span of floral visit (s)')
```

## Foraging trips per day

explanation ... foraging hour and time of visits per flower

```{r}
# function to estimate the number of foraging trip per individual i in 
# hive j, depending on the quality of the hive.

N_foraging_trips <- 
  
  function(iter, # bees per hive 
           time_foragin, # effective time to forage during the day
           time_per_visit, # posterior distribution of time spend per visit
           seed = 123) { 
    
    set.seed(seed)
    time_foragin <- sample(time_foragin, iter, T)
    
    t1 <- Sys.time()
    visits_bee <- 
      sapply(1:iter, FUN = 
               function(x) {
                 
                 time <- 0
                 vis <- 0
                 
                 while (time < time_foragin[[x]]) {
                   time <- time + sample(time_per_visit, 1)
                   vis <- vis + 1
                 }
                 
                 vis
                 
               })
    message(paste('Execution time', Sys.time() - t1))
    
    return(visits_bee)
    
  }

```


```{r, fig.cap= 'Orange = high-quality hives; Lightblue = low-quality hives'}
# t1 <- Sys.time()
# visits_day <- N_foraging_trips(iter = 2e4, 
#                                time_foragin = foraging_time_LQ, 
#                                time_per_visit = time_visit_honeybee)
# Sys.time() - t1

visits_day <- readRDS('visits_day_LQ.rds')


# t1 <- Sys.time()
# visits_day_HQ <- N_foraging_trips(iter = 2e4, 
#                                time_foragin = foraging_time_HQ, 
#                                time_per_visit = time_visit_honeybee)
# Sys.time() - t1

visits_day_HQ <- readRDS('visits_day_HQ.rds')

plot(density(visits_day), main = '', xlab = 'Number of floral visits of\n a single forager honeybee bee per day',
     lwd = 4, col = 'lightblue', xlim = c(395, 2000))
lines(density(visits_day_HQ), lwd = 4, col = 'tan1')

```

# (iii) Foraging pattern of honeybees

# (iv) Floral visits and pollen deposition

# (v) Final crop yield

